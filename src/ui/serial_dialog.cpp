/******************************************************************************
 * @file   serial_dialog.cpp
 * @brief  Serial (USB) selection dialog box implementation file.
 *
 * @author brice.c.aa
 ******************************************************************************/

// Related Header
#include "serial_dialog.h"

// C++ Standard Library Headers
#include <sys/stat.h>

// Other Library Headers
#include <libudev.h>  // userspace devices
#include <QDebug>     // Qt::Core

// Project Headers
#include "ui_serial_dialog.h"  // auto-generated by Qt

/* --- TABLE OF CONTENTS ---
 * !Helper Functions
 * !Main Window
 * !Getters & Setters
 * !Uncategorized
 */

/**
 * @brief Standard constructor.
 *
 * @param device_type The "tty" device type to be managed (e.g., "USB", "ACM")
 * @param parent Owning Qt widget (default: nullptr)
 */
SerialDialog::SerialDialog(const std::string& device_type,
                           const bool debug_mode, QWidget* parent)
    : QDialog(parent), device_type_("tty" + device_type),
      debug_mode_(debug_mode), ui_(new Ui::SerialDialog) {
    ui_->setupUi(this);

    // Populate the combobox
    auto devices = GetDeviceList();
    if (!devices.empty()) {
        ui_->cb_serial_name->addItems(devices);
        ui_->pb_connect->setEnabled(true);
    }
}

/**
 * @brief Standard QDialog destructor.
 */
SerialDialog::~SerialDialog() {
    delete ui_;
}

//------------------------------------------------------------------------------
// !Helper Functions
//------------------------------------------------------------------------------

/**
 * @brief Check whether the app is being run in Windows Subsystem for Linux.
 *
 * @return true if `WSL` directory is detected; false otherwise
 */
bool SerialDialog::isRunningOnWSL() {
    const char* wsl_path = "/run/WSL";

    struct stat buf {};

    return (stat(wsl_path, &buf) == 0 && S_ISDIR(buf.st_mode));
}

/**
 * @brief Searches the Linux `tty` serial list and returns all devices that
 *        match `device_type_`.
 *
 * @return List of available serial devices
 */
QStringList SerialDialog::GetDeviceList() {
    QStringList device_list;

    if (isRunningOnWSL()) {
        qWarning() << "[WARN] Serial - You seem to be running this on "
                      "WSL/WSL2. Please ensure you have properly forwarded "
                      "your USB connections.";
    }

    // Create udev context
    struct udev* udev = udev_new();
    if (udev == nullptr) {
        qCritical() << "[ERROR] Serial - Unable to create udev context";
        return device_list;
    }

    // Initialize udev enumerator
    struct udev_enumerate* enumerate = udev_enumerate_new(udev);
    udev_enumerate_add_match_subsystem(enumerate, "tty");
    udev_enumerate_scan_devices(enumerate);

    // Get list of devices
    struct udev_list_entry* devices = udev_enumerate_get_list_entry(enumerate);
    struct udev_list_entry* entry = nullptr;

    // Iterate through list
    udev_list_entry_foreach(entry, devices) {
        // Retrieve device information
        const char* path = udev_list_entry_get_name(entry);
        struct udev_device* device = udev_device_new_from_syspath(udev, path);
        const char* devnode = udev_device_get_devnode(device);

        if (debug_mode_) {
            // Print out all found devices
            qDebug() << "[DEBUG] Serial - Found" << devnode;
        }

        // Only list physical connections
        if (device && strstr(devnode, device_type_.c_str())) {
            device_list.append(QString::fromUtf8(devnode));
        }

        // Free udev device object before moving on to next one
        udev_device_unref(device);
    }

    // Clean up udev objects
    udev_enumerate_unref(enumerate);
    udev_unref(udev);

    // Return device list
    device_list.removeDuplicates();  // just in case
    return device_list;
}

//------------------------------------------------------------------------------
// !Main Window
//------------------------------------------------------------------------------

/**
 * @brief Event handler for "Serial Name" combo box selection.
 *        Enables the "Connect" button.
 *
 * @param sel The device name selected by the user
 */
void SerialDialog::on_cb_serial_name_textActivated(const QString& sel) {
    // Since the device name has been specified, enable Connect button
    ui_->pb_connect->setEnabled(true);
}

/**
 * @brief Event handler for "Connect" button (single click).
 *
 * @note Since there are various types of serial devices (e.g., "USB", "ASM",
 *       etc.), the calling code is responsible for establishing the connection.
 */
void SerialDialog::on_pb_connect_clicked() {
    // Save selected device name
    selected_device_ = ui_->cb_serial_name->currentText().toStdString();

    // Close the dialog and return `QDialog::Accepted`
    SerialDialog::accept();
}

/**
 * @brief Give the user another way to close the dialog
 *        (in addition to the X in the menu bar).
 */
void SerialDialog::on_pb_cancel_clicked() {
    // Close the dialog and return `QDialog::Rejected`
    SerialDialog::reject();
}

//------------------------------------------------------------------------------
// !Getters & Setters
//------------------------------------------------------------------------------

/**
 * @brief Returns the Linux device name used to communicate with a serial device.
 *
 * @return Device name for serial connection
 */
std::string SerialDialog::GetDeviceName() {
    return selected_device_;
}

//------------------------------------------------------------------------------
// !Uncategorized
//------------------------------------------------------------------------------
