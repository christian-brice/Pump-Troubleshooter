/******************************************************************************
 * @file   main_window.cpp
 * @brief  Main app window implementation file.
 *
 * @author brice.c.aa
 ******************************************************************************/

// Related Header
#include "main_window.h"

// C++ Standard Library Headers
#include <bitset>
#include <sys/stat.h>

// Other Library Headers
#include <QMessageBox>      // Qt::Widgets
#include <QSerialPortInfo>  // Qt::SerialPort

// Project Headers
#include "ui_main_window.h"  // auto-generated by Qt

/* --- TABLE OF CONTENTS ---
 * !Helper Functions
 * !Menu Bar
 * !Main Window
 * !Uncategorized
 */

/**
 * @brief Standard constructor.
 *
 * @param parent Owning Qt widget (default: nullptr)
 */
MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent), ui_(new Ui::MainWindow),
      ser_water_(new QSerialPort(this)) {
    ui_->setupUi(this);

    // Check if app is running in Windows Subsystem for Linux (WSL2)
    {
        const char* wsl_path = "/run/WSL";

        struct stat buf {};

        if (stat(wsl_path, &buf) == 0 && S_ISDIR(buf.st_mode)) {
            qWarning()
                << "[WARN] You seem to be running this on WSL2. Please ensure "
                   "you have properly forwarded your USB connections.";
        }
    }

    // Set initial state UI of elements
    ui_->a_debug_mode->setChecked(debug_mode_);

    // Populate the Serial Devices combo box
    ui_->pb_refresh->animateClick();
}

/**
 * @brief Standard destructor.
 */
MainWindow::~MainWindow() {
    if (ser_water_->isOpen()) {
        ser_water_->close();
    }

    delete ui_;
}

//------------------------------------------------------------------------------
// !Helper Functions
//------------------------------------------------------------------------------

namespace {  // local to this file

/**
 * @brief Converts QBitArray to QByteArray, since Qt doesn't seem to support
 *        this natively.
 *
 * @param bits The QBitArray to convert
 * @return A QByteArray logically equivalent to the input QBitArray
 *
 * @note See the following Stack Overflow thread:
 *   https://stackoverflow.com/questions/8776261/qbitarray-to-qbytearray
 */
QByteArray BitsToBytes(QBitArray bits) {
    // Prepare byte array object
    QByteArray bytes;
    bytes.resize(bits.count() / 8 + 1);
    bytes.fill(0);

    // Convert from QBitArray to QByteArray
    for (int b = 0; b < bits.count(); ++b) {
        bytes[b / 8] = (bytes.at(b / 8) | ((bits[b] ? 1 : 0) << (b % 8)));
    }

    return bytes;
}

/**
 * @brief Converts a QBitArray to QString (for printing), since Qt doesn't seem
 *        to support this natively.
 *
 * @param bits The QBitArray to convert
 * @return A QString representing the input QBitArray
 *
 * @note See the following Stack Overflow thread:
 *   https://stackoverflow.com/questions/46101782/qt-how-do-i-convert-qbitarray-to-qstring
 */
QString BitsToStr(QBitArray bits) {
    QString str;

    for (auto i = bits.size() - 1; i >= 0; --i) {
        str += bits.at(i) ? '1' : '0';
    }

    return str;
}

}  // namespace

void MainWindow::WriteData(const QBitArray data) {
    // Send data (and verify)
    const auto ba = BitsToBytes(data);
    const qint64 written = ser_water_->write(ba);
    if (written != ba.size()) {
        qCritical() << "[ERROR] Failed to write all data to "
                    << ser_water_->portName();
        QMessageBox::critical(this, tr("Error"), ser_water_->errorString());
    }

    if (debug_mode_) {
        qDebug() << "[DEBUG] Sent:" << BitsToStr(data);
    }
}

//------------------------------------------------------------------------------
// !Menu Bar
//------------------------------------------------------------------------------

/**
 * @brief Event handler for "Preferences" menu bar action "Debug Mode".
 *        Toggles debug prinouts for this object and all its children.
 */
void MainWindow::on_a_debug_mode_toggled(bool checked) {
    debug_mode_ = checked;

    if (debug_mode_) {
        qDebug() << "[DEBUG] Debug mode enabled";
    }
}

//------------------------------------------------------------------------------
// !Main Window
//------------------------------------------------------------------------------

/**
 * @brief Connects to the highlighted serial device upon selection.
 */
void MainWindow::on_cb_serial_name_currentTextChanged(const QString& sel) {
    // Clear the existing Serial object, if it exists
    if (ser_water_->isOpen()) {
        ser_water_->close();
    }

    // Set port options
    ser_water_->setPortName(sel);
    ser_water_->setBaudRate(QSerialPort::Baud115200);
    ser_water_->setDataBits(QSerialPort::Data8);
    ser_water_->setParity(QSerialPort::NoParity);
    ser_water_->setStopBits(QSerialPort::OneStop);
    ser_water_->setFlowControl(QSerialPort::NoFlowControl);

    // Only continue if "open" is successful
    if (!ser_water_->open(QIODevice::ReadWrite)) {
        qCritical() << "[ERROR] Failed to open port " << ser_water_->portName();
        QMessageBox::critical(this, tr("Error"), ser_water_->errorString());
        return;
    }

    // Enable fluid system controls
    ui_->tb_a_in->setEnabled(true);
    ui_->tb_a_in->setStyleSheet("color: red;");
    ui_->tb_b_in->setEnabled(true);
    ui_->tb_b_in->setStyleSheet("color: red;");
    ui_->tb_a_out->setEnabled(true);
    ui_->tb_a_out->setStyleSheet("color: red;");
    ui_->tb_b_out->setEnabled(true);
    ui_->tb_b_out->setStyleSheet("color: red;");
}

/**
 * @brief Refreshes the list of available serial devices.
 */
void MainWindow::on_pb_refresh_clicked() {
    if (debug_mode_) {
        qDebug() << "[DEBUG] Refreshing available serial ports...";
    }

    // Populate serial device selector combo box
    bool found = false;
    const auto ports = QSerialPortInfo::availablePorts();
    for (const auto& port_info : ports) {
        if (debug_mode_) {
            qDebug() << "[DEBUG] Found SerialPort with following metadata\n"
                     << "  Port:" << port_info.portName() << "\n"
                     << "  Location:" << port_info.systemLocation() << "\n"
                     << "  Description:" << port_info.description() << "\n"
                     << "  Manufacturer:" << port_info.manufacturer() << "\n"
                     << "  Serial number:" << port_info.serialNumber();
        }

        // Populate ComboBox (new items are appended to existing list)
        ui_->cb_serial_name->addItem(port_info.portName());
        found = true;  // only needs to be set once
    }

    if (!found) {
        qWarning() << "[WARN] No serial devices were found!";
    }
}

/**
 * @brief Controls state of A-side fluid input.
 *
 * @note Bit field "0b123":
 *         1: A_IN | 2: B_IN | 3: A_OUT | 4: B_OUT
 *       These are indexed backwards when using QBitArray, since it starts from
 *       the least significant bit:
 *         0: B_OUT | 1: A_OUT | 2: B_IN | 3: A_IN
 */
void MainWindow::on_tb_a_in_clicked() {
    if (ui_->tb_a_in->isChecked()) {
        // Set visual indicator
        ui_->tb_a_in->setStyleSheet("color: green;");

        // Disable opposite button
        current_cmd_.setBit(1, false);  // zero opposite action's bit
        ui_->tb_a_out->setEnabled(false);
        ui_->tb_a_out->setStyleSheet("color: gray;");

        // Set start command
        current_cmd_.setBit(3, true);
    } else {
        // Reset visual indicator
        ui_->tb_a_in->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_a_out->setEnabled(true);
        ui_->tb_a_out->setStyleSheet("color: red;");

        // Set stop command
        current_cmd_.setBit(3, false);  // only zero this action's bit
    }

    WriteData(current_cmd_);
}

/**
 * @brief Controls state of B-side fluid input.
 *
 * @note Bit field "0b123":
 *         1: A_IN | 2: B_IN | 3: A_OUT | 4: B_OUT
 *       These are indexed backwards when using QBitArray, since it starts from
 *       the least significant bit:
 *         0: B_OUT | 1: A_OUT | 2: B_IN | 3: A_IN
 */
void MainWindow::on_tb_b_in_clicked() {
    if (ui_->tb_b_in->isChecked()) {
        // Set visual indicator
        ui_->tb_b_in->setStyleSheet("color: green;");

        // Disable opposite button
        current_cmd_.setBit(0, false);  // only zero opposite action's bit
        ui_->tb_b_out->setEnabled(false);
        ui_->tb_b_out->setStyleSheet("color: gray;");

        // Set start command
        current_cmd_.setBit(2, true);
    } else {
        // Reset visual indicator
        ui_->tb_b_in->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_b_out->setEnabled(true);
        ui_->tb_b_out->setStyleSheet("color: red;");

        // Set stop command
        current_cmd_.setBit(2, false);  // only zero this action's bit
    }

    WriteData(current_cmd_);
}

/**
 * @brief Controls state of A-side fluid output.
 *
 * @note Bit field "0b123":
 *         1: A_IN | 2: B_IN | 3: A_OUT | 4: B_OUT
 *       These are indexed backwards when using QBitArray, since it starts from
 *       the least significant bit:
 *         0: B_OUT | 1: A_OUT | 2: B_IN | 3: A_IN
 */
void MainWindow::on_tb_a_out_clicked() {
    if (ui_->tb_a_out->isChecked()) {
        // Set visual indicator
        ui_->tb_a_out->setStyleSheet("color: green;");

        // Disable opposite button
        current_cmd_.setBit(3, false);  // only zero opposite action's bit
        ui_->tb_a_in->setEnabled(false);
        ui_->tb_a_in->setStyleSheet("color: gray;");

        // Set start command
        current_cmd_.setBit(1, true);
    } else {
        // Reset visual indicator
        ui_->tb_a_out->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_a_in->setEnabled(true);
        ui_->tb_a_in->setStyleSheet("color: red;");

        // Set stop command
        current_cmd_.setBit(1, false);  // only zero this action's bit
    }

    WriteData(current_cmd_);
}

/**
 * @brief Controls state of B-side fluid output.
 *
 * @note Bit field "0b123":
 *         1: A_IN | 2: B_IN | 3: A_OUT | 4: B_OUT
 *       These are indexed backwards when using QBitArray, since it starts from
 *       the least significant bit:
 *         0: B_OUT | 1: A_OUT | 2: B_IN | 3: A_IN
 */
void MainWindow::on_tb_b_out_clicked() {
    if (ui_->tb_b_out->isChecked()) {
        // Set visual indicator
        ui_->tb_b_out->setStyleSheet("color: green;");

        // Disable opposite button
        current_cmd_.setBit(2, false);  // only zero opposite action's bit
        ui_->tb_b_in->setEnabled(false);
        ui_->tb_b_in->setStyleSheet("color: gray;");

        // Set start command
        current_cmd_.setBit(0, true);
    } else {
        // Reset visual indicator
        ui_->tb_b_out->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_b_in->setEnabled(true);
        ui_->tb_b_in->setStyleSheet("color: red;");

        // Set stop command
        current_cmd_.setBit(0, false);  // only zero this action's bit
    }

    WriteData(current_cmd_);
}

//------------------------------------------------------------------------------
// !Uncategorized
//------------------------------------------------------------------------------
