/******************************************************************************
 * @file   main_window.cpp
 * @brief  Main app window implementation file.
 *
 * @author brice.c.aa
 ******************************************************************************/

// Related Header
#include "main_window.h"

// C++ Standard Library Headers
#include <bitset>
#include <sys/stat.h>

// Other Library Headers
#include <QMessageBox>  // Qt::Widgets

// Project Headers
#include "ui_main_window.h"  // auto-generated by Qt

/* --- TABLE OF CONTENTS ---
 * !Helper Functions
 * !Thread Handlers (slots)
 * !Menu Bar
 * !Main Window
 * !Uncategorized
 */

/**
 * @brief Standard constructor.
 *
 * @param parent Owning Qt widget (default: nullptr)
 */
MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent), ui_(new Ui::MainWindow) {
    ui_->setupUi(this);

    // Check if app is running in Windows Subsystem for Linux (WSL2)
    {
        const char* wsl_path = "/run/WSL";

        struct stat buf {};

        if (stat(wsl_path, &buf) == 0 && S_ISDIR(buf.st_mode)) {
            qWarning()
                << "[WARN] You seem to be running this on WSL2. Please ensure "
                   "you have properly forwarded your USB connections.";
        }
    }

    // Set initial state UI of elements
    ui_->a_debug_mode->setChecked(debug_mode_);

    // Populate the Serial Devices combo box
    ui_->pb_refresh->animateClick();

    // --- Thread Management ---

    /* In Qt, thread management for subclassed QThreads generally has 4 steps:
     *   1) Initialize a new QThread object
     *   2) Register a QThread signal to return data to a MainWindow handler
     *   3) Register the QThread's exit signal to its own destruction slot
     *   4) Spin off the QThread
     * If the thread loops continuously, there is a fifth step:
     *   5) In the MainWindow destructor, interrupt or forcibly stop the QThread
     */

    // Pump thread
    pump_thread_ = new PumpThread(this, debug_mode_);

    // - MainWindow signals
    connect(this, &MainWindow::UpdateDebugMode,  // update debug mode
            pump_thread_, &PumpThread::SetDebugMode);

    connect(this, &MainWindow::OpenConnection,  // connect to serial device
            pump_thread_, &PumpThread::OpenConnection);

    connect(this, &MainWindow::RequestAvailable,  // refresh serial devices
            pump_thread_, &PumpThread::RefreshConnections);

    connect(this, &MainWindow::CommandPumps,  // change pump state
            pump_thread_, &PumpThread::UpdateState);

    // - MainWindow slots
    connect(pump_thread_, &PumpThread::InformAvailable,  // update device list
            this, &MainWindow::HandleDeviceListUpdate);

    // - Thread cleanup
    connect(pump_thread_, &PumpThread::finished,      // when thread exits
            pump_thread_, &PumpThread::deleteLater);  // ... deallocate

    pump_thread_->start();
}

/**
 * @brief Standard destructor.
 */
MainWindow::~MainWindow() {
    // Wrap up the worker thread(s) gracefully
    if (pump_thread_ != nullptr && pump_thread_->isRunning()) {
        pump_thread_->requestInterruption();  // signal thread to stop looping
        pump_thread_->wait();  // wait for thread cleanup to finish
    }

    delete ui_;
}

//------------------------------------------------------------------------------
// !Helper Functions
//------------------------------------------------------------------------------

namespace {  // local to this file

}  // namespace

//------------------------------------------------------------------------------
// !Thread Handlers (slots)
//------------------------------------------------------------------------------

/**
 * @brief Refreshes the list of available serial devices.
 *
 * @param available_ports Vector provided by PumpThread signal
 */
void MainWindow::HandleDeviceListUpdate(
    const std::vector<QString>& available_ports) {
    for (const auto& port : available_ports) {
        // Populate the ComboBox
        ui_->cb_serial_name->addItem(port);
    }
}

//------------------------------------------------------------------------------
// !Menu Bar
//------------------------------------------------------------------------------

/**
 * @brief Event handler for "Preferences" menu bar action "Debug Mode".
 *        Toggles debug prinouts for this object and all its children.
 */
void MainWindow::on_a_debug_mode_toggled(bool checked) {
    debug_mode_ = checked;

    emit UpdateDebugMode(debug_mode_);  // send to PumpThread

    if (debug_mode_) {
        qDebug() << "[DEBUG] Debug mode enabled";
    }
}

//------------------------------------------------------------------------------
// !Main Window
//------------------------------------------------------------------------------

/**
 * @brief Connects to the highlighted serial device upon selection.
 */
void MainWindow::on_cb_serial_name_currentTextChanged(const QString& sel) {
    // Tell thread to open a connection to SerialWater
    emit OpenConnection(sel);

    // Enable fluid system controls
    ui_->tb_a_in->setEnabled(true);
    ui_->tb_a_in->setStyleSheet("color: red;");
    ui_->tb_b_in->setEnabled(true);
    ui_->tb_b_in->setStyleSheet("color: red;");
    ui_->tb_a_out->setEnabled(true);
    ui_->tb_a_out->setStyleSheet("color: red;");
    ui_->tb_b_out->setEnabled(true);
    ui_->tb_b_out->setStyleSheet("color: red;");
}

/**
 * @brief Requests an updated list of available serial devices.
 */
void MainWindow::on_pb_refresh_clicked() {
    emit RequestAvailable();
}

/**
 * @brief Controls state of A-side (left) fluid input.
 */
void MainWindow::on_tb_a_in_clicked() {
    if (ui_->tb_a_in->isChecked()) {
        // Set visual indicator
        ui_->tb_a_in->setStyleSheet("color: green;");

        // Disable opposite button
        ui_->tb_a_out->setEnabled(false);
        ui_->tb_a_out->setStyleSheet("color: gray;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kLeftFill);
    } else {
        // Reset visual indicator
        ui_->tb_a_in->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_a_out->setEnabled(true);
        ui_->tb_a_out->setStyleSheet("color: red;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kLeftStop);
    }
}

/**
 * @brief Controls state of B-side (right) fluid input.
 */
void MainWindow::on_tb_b_in_clicked() {
    if (ui_->tb_b_in->isChecked()) {
        // Set visual indicator
        ui_->tb_b_in->setStyleSheet("color: green;");

        // Disable opposite button
        ui_->tb_b_out->setEnabled(false);
        ui_->tb_b_out->setStyleSheet("color: gray;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kRightFill);
    } else {
        // Reset visual indicator
        ui_->tb_b_in->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_b_out->setEnabled(true);
        ui_->tb_b_out->setStyleSheet("color: red;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kRightStop);
    }
}

/**
 * @brief Controls state of A-side (left) fluid output.
 */
void MainWindow::on_tb_a_out_clicked() {
    if (ui_->tb_a_out->isChecked()) {
        // Set visual indicator
        ui_->tb_a_out->setStyleSheet("color: green;");

        // Disable opposite button
        ui_->tb_a_in->setEnabled(false);
        ui_->tb_a_in->setStyleSheet("color: gray;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kLeftDrain);
    } else {
        // Reset visual indicator
        ui_->tb_a_out->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_a_in->setEnabled(true);
        ui_->tb_a_in->setStyleSheet("color: red;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kLeftStop);
    }
}

/**
 * @brief Controls state of B-side (right) fluid output.
 */
void MainWindow::on_tb_b_out_clicked() {
    if (ui_->tb_b_out->isChecked()) {
        // Set visual indicator
        ui_->tb_b_out->setStyleSheet("color: green;");

        // Disable opposite button
        ui_->tb_b_in->setEnabled(false);
        ui_->tb_b_in->setStyleSheet("color: gray;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kRightDrain);
    } else {
        // Reset visual indicator
        ui_->tb_b_out->setStyleSheet("color: red;");

        // Re-enable opposite button
        ui_->tb_b_in->setEnabled(true);
        ui_->tb_b_in->setStyleSheet("color: red;");

        // Update pump state
        emit CommandPumps(PumpThread::State::kRightStop);
    }
}

//------------------------------------------------------------------------------
// !Uncategorized
//------------------------------------------------------------------------------
